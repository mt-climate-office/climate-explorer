<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Climate Explorer</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />

    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
    <script src="https://unpkg.com/papaparse@5.5.2/papaparse.min.js"></script>
    <script src="https://unpkg.com/georaster"></script>
    <script src="https://unpkg.com/georaster-layer-for-leaflet"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.0/chart.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/hammer.js/2.0.8/hammer.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chartjs-plugin-zoom/2.0.1/chartjs-plugin-zoom.min.js"></script>
    <script src="https://unpkg.com/flatgeobuf@3.22.0/dist/flatgeobuf-geojson.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-trendline@2.1.7/src/chartjs-plugin-trendline.min.js"></script>
    <script src="https://unpkg.com/chroma-js@2.0.3/chroma.min.js"></script>
    <style>
        
        body,
        html {
            margin: 0;
            padding: 0;
            height: 100%;
            font-family: Arial, sans-serif;
            background: #FFFFFF;
        }

        .container {
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        .tabs {
            display: flex;
            padding: 20px;
            gap: 10px;
            background: #FFFFFF;
        }

        .tab {
            flex: 1;
            padding: 12px 24px;
            cursor: pointer;
            background: #e0e0e0;
            text-align: center;
            border: none;
            /* border-radius: 25px; */
            font-size: 16px;
            transition: all 0.3s ease;
            color: #666;
        }

        .tab:hover {
            background: #d0d0d0;
        }

        .tab.active {
            background: #4a90e2;
            color: white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .content {
            flex-grow: 1;
            position: relative;
            margin: 0 20px 20px 20px;
            border-radius: 15px;
            overflow: hidden;
            border: 1px solid #ddd;
            background: white;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .map {
            height: 100%;
            width: 100%;
        }

        .sidebar {
            display: none;
            position: absolute;
            right: 20px;
            top: 20px;
            bottom: 20px;
            width: 500px;
            background: rgba(255, 255, 255, 0.25);
            /* Made more transparent */
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            overflow-y: auto;
            backdrop-filter: blur(5px);
            /* Added blur effect for better readability */
        }

        .section-title {
            margin: 0px 0px;
        }

        .sidebar-title {
            margin: 0px 0px 10px 0px;
        }

        /* Make form elements and plot container fully opaque for contrast */
        select,
        .multiselect,
        .plot-container {
            background: white;
        }

        .sidebar.active {
            display: flex;
            flex-direction: column;
        }

        select {
            width: 100%;
            margin: 10px 0;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #ddd;
            background: white;
            font-size: 14px;
        }

        select:focus {
            outline: none;
            border-color: #4a90e2;
        }

        .multiselect {
            border: 1px solid #ddd;
            padding: 12px;
            margin: 10px 0;
            min-height: 120px;
            overflow-y: auto;
            border-radius: 8px;
            background: white;
        }

        .radio-group {
            background: white; 
            padding: 10px; 
            border-radius: 8px; 
            border: 1px solid #ddd; 
            margin: 10px 0;
        }

        .multiselect label {
            display: block;
            margin: 8px 0;
            color: #444;
        }

        .plot-container {
            margin-top: 20px;
            flex-grow: 1;
            min-height: 300px;
            background: white;
            border-radius: 8px;
            border: 1px solid #ddd;
        }

        .chart-container {
            width: 800px;
            height: 400px;
            margin: 20px auto;
            position: relative;
        }

        .logo {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 50px;
            height: 50px;
            z-index: 10;
            background: #fff;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-family: Arial, sans-serif;
            color: #333;
            border: 2px solid #ddd;
        }

        .controls {
            text-align: center;
            margin: 10px;
        }

        button {
            padding: 8px 16px;
            margin: 0 5px;
            cursor: pointer;
        }

        .legend {
            color: #555;
            padding: 6px 8px;
            font: 13 pxArial, Helvetica, sans-serif;
            font-weight: bold;
            background: white;
            background: rgba(255, 255, 255, 0.8);
            /*            box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);*/
            border-radius: 5px;
            border-bottom-left-radius: 2px;
            border-bottom-right-radius: 2px;
            border-top-left-radius: 2px;
            border-top-right-radius: 2px;
            border-bottom: none;
            border-bottom-width: initial;
            border-bottom-style: none;
            border-bottom-color: initial;
            border: 2px solid rgba(0, 0, 0, .3);
            border-radius: 4px;
            width: 300px;
        }

        .legend span,
        .legend label {
            display: block;
            width: 55px;
            height: 18px;
            float: left;
            opacity: 0.7;
            text-align: center;
            font-size: 80%
        }

        .legend ul {
            text-align: center;
            display: block;
            list-style-type: none;
            padding: 0;
            margin: 0;
            clear: both;
        }

        .legend li {
            display: inline-block;
            width: 1.25px;
            height: 22px;
        }

        .legend .min {
            float: left;
            padding-bottom: 5px;
            padding-left: 20px;
        }

        .legend .max {
            float: right;
            padding-bottom: 5px;
            padding-right: 20px;
        }

        .legend-title {
            display: block;
            text-align: center;
            margin-bottom: 5px;
            font-weight: bold;
            font-size: 14px;
        }

        .legend span {
            width: 50px;
            height: 18px;
            float: left;
            margin: 0 8px 0 0;
            opacity: 0.7;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="tabs">
            <a href="https://climate.umt.edu" style="display: flex; align-items: center; margin-right: 20px;">
                <img src="https://data.climate.umt.edu/website/assets/MCO_logo.png" alt="MCO Logo"
                    style="height: 40px;">
            </a>
            <button class="tab active" onclick="switchTab(0)">Historical Trends</button>
            <button class="tab" onclick="switchTab(1)">Climate Projections</button>
            <button class="tab" onclick="switchTab(2)">Report Builder</button>
        </div>
        <div class="content">
            <div id="map" class="map"></div>
            <div class="sidebar active">
                <h2 class="sidebar-title">Climate and Vegetation Trends</h2>
                <h3 class="section-title">Variable Selection</h3>
                <select id="historical-variable-selector">
                    <optgroup label="GridMET Variables">
                        <option value="erc">Energy Release Component</option>
                        <option value="etr">Potential ET (Alfalfa)</option>
                        <option value="pet">Potential ET (Grass)</option>
                        <option value="pr" selected="selected">Precipitation</option>
                        <option value="rmax">Maximum Relative Humidity</option>
                        <option value="rmin">Minimum Relative Humidity</option>
                        <option value="tmmn">Minumum Temperature</option>
                        <option value="tmmx">Maximum Temperature</option>
                        <option value="vpd">Vapor Pressure Deficit</option>
                        <option value="vs">Wind Speed</option>
                    </optgroup>
                    <optgroup label="Satellite Indicators">
                        <option value="afg">RAP Annual Forb and Grass Cover</option>
                        <option value="bgr">RAP Bare Ground Cover</option>
                        <option value="pfg">RAP Perennial Forb and Grass Cover</option>
                        <option value="shr">RAP Shrub Cover</option>
                        <option value="tre">RAP Tree Cover</option>
                        <option value="evi">MOD13 EVI</option>
                        <option value="ndvi">MOD13 NDVI</option>
                        <option value="et_m16">MOD16 ET</option>
                        <option value="pet_m16">MOD16 PET</option>
                        <option value="gpp">MOD17 GPP</option>
                        <option value="afgnpp">RAP Forb and Grass NPP</option>
                        <option value="pfgnpp">RAP Perennial Forb and Grass NPP</option>
                        <option value="shrnpp">RAP Shrub NPP</option>
                        <option value="trenpp">RAP Tree NPP</option>
                    </optgroup>
                </select>
                <h3 class="section-title">Time Period</h3>
                <select id="historical-time-selector">
                    <option value="annual">Annual</option>
                    <option value="jan">January</option>
                    <option value="feb">February</option>
                    <option value="mar">March</option>
                    <option value="apr">April</option>
                    <option value="may">May</option>
                    <option value="jun">June</option>
                    <option value="jul">July</option>
                    <option value="aug">August</option>
                    <option value="sep">September</option>
                    <option value="oct">October</option>
                    <option value="nov">November</option>
                    <option value="dec">December</option>
                </select>
                <div class="plot-container">
                    <canvas id="historical-plot" style="width: 100%; height: 100%;"></canvas>
                </div>
            </div>
            <div class="sidebar">
                <h2 class="sidebar-title">CMIP6 Projections</h2>
                <h3 class="section-title">Variable</h3>
                <select id="future-variable-selector">
                    <optgroup label="CMIP6 Variables">
                        <option value="penman">Potential ET</option>
                        <option value="tas">Avg. Air Temperature</option>
                        <option value="tasmax">Max. Air Temperature</option>
                        <option value="tasmin">Min. Air Temperature</option>
                        <option value="sfcWind">Wind Speed</option>
                        <option value="pr">Precipitation</option>
                    </optgroup>
                    <optgroup label="Derived Variables">
                        <option value="above90">Days Above 90°F</option>
                        <option value="freeze-free">Freeze Free Days</option>
                        <option value="gdd">Growing Degree Days</option>
                        <option value="con-wet">Consecutive Wet Days</option>
                        <option value="con-dry">Consecutive Dry Days</option>
                        <option value="dry-days">Dry Days</option>
                        <option value="wet-days">Wet Days</option>
                    </optgroup>
                </select>
                <h3 class="section-title">Scenario</h3>
                <div class="multiselect">
                    <label><input type="checkbox" value="ssp126"> Moderating Emissions (SSP1-2.6)</label>
                    <label><input type="checkbox" value="ssp245"> Middle of the Road (SSP2-4.5)</label>
                    <label><input type="checkbox" value="ssp370"> High Emissions (SSP3-7.0)</label>
                    <label><input type="checkbox" value="ssp585"> Accelerating Emissions (SSP5-8.5)</label>
                </div>
                <h3 class="section-title">Plot Options</h3>
                <h4 class="section-title">Plot Type</h4>
                <div class="radio-group">
                    <label><input type="radio" name="plot-type" value="timeseries"> Timeseries</label>
                    <label><input type="radio" name="plot-type" value="monthly"> Monthly Trend</label>
                </div>

                <h4 class="section-title">Time Period</h4>
                <div class="radio-group">
                    <label><input type="radio" name="time-period" value="end"> End of Century</label>
                    <label><input type="radio" name="time-period" value="mid"> Mid Century</label>
                    <label><input type="radio" name="time-period" value="ref"> Reference Period</label>
                </div>

                <h4 class="section-title">Map Type</h4>
                <div class="radio-group">
                    <label><input type="radio" name="map-type" value="average"> Period Average</label>
                    <label><input type="radio" name="map-type" value="difference"> Difference From Normal</label>
                </div>
                <div class="plot-container">
                    <canvas id="future-plot"></canvas>
                </div>
            </div>
            <div class="sidebar">
                <h2 class="sidebar-title">Generate a Report</h2>
                <h3 class="section-title">Historical Variables</h3>
                <div class="multiselect">
                    <h5 style="margin: 2px 0">GridMET Variables</h5>
                    <label><input type="checkbox" value="erc">Energy Release Component</label>
                    <label><input type="checkbox" value="etr">Potential ET (Alfalfa)</label>
                    <label><input type="checkbox" value="pet">Potential ET (Grass)</label>
                    <label><input type="checkbox" value="pr">Precipitation</label> 
                    <label><input type="checkbox" value="rmax">Maximum Relative Humidity</label>
                    <label><input type="checkbox" value="rmin">Minimum Relative Humidity</label>
                    <label><input type="checkbox" value="tmmn">Minimum Temperature</label>
                    <label><input type="checkbox" value="tmmx">Maximum Temperature</label>
                    <label><input type="checkbox" value="vpd">Vapor Pressure Deficit</label>
                    <label><input type="checkbox" value="vs">Wind Speed</label>
                    <h5 style="margin: 2px 0">Satellite Indicators</h5>
                    <label><input type="checkbox" value="afg">RAP Annual Forb and Grass Cover</label>
                    <label><input type="checkbox" value="bgr">RAP Bare Ground Cover</label>
                    <label><input type="checkbox" value="pfg">RAP Perennial Forb and Grass Cover</label>
                    <label><input type="checkbox" value="shr">RAP Shrub Cover</label>
                    <label><input type="checkbox" value="tre">RAP Tree Cover</label>
                    <label><input type="checkbox" value="evi">MOD13 EVI</label>
                    <label><input type="checkbox" value="ndvi">MOD13 NDVI</label>
                    <label><input type="checkbox" value="et_m16">MOD16 ET</label>
                    <label><input type="checkbox" value="pet_m16">MOD16 PET</label>
                    <label><input type="checkbox" value="gpp">MOD17 GPP</label>
                    <label><input type="checkbox" value="afgnpp">RAP Forb and Grass NPP</label>
                    <label><input type="checkbox" value="pfgnpp">RAP Perennial Forb and Grass NPP</label>
                    <label><input type="checkbox" value="shrnpp">RAP Shrub NPP</label>
                    <label><input type="checkbox" value="trenpp">RAP Tree NPP</label>
                </div>

                <h3 class="section-title">Future Variables</h3>
                <div class="multiselect">
                    <h5 style="margin: 2px 0">CMIP6 Variables</h5>
                    <label><input type="checkbox" value="penman">Potential ET</label>
                    <label><input type="checkbox" value="tas">Avg. Air Temperature</label>
                    <label><input type="checkbox" value="tasmax">Max. Air Temperature</label>
                    <label><input type="checkbox" value="tasmin">Min. Air Temperature</label>
                    <label><input type="checkbox" value="sfcWind">Wind Speed</label>
                    <label><input type="checkbox" value="pr">Precipitation</label>

                    <h5 style="margin: 2px 0">Derived Variables</h5>
                    <label><input type="checkbox" value="above90">Days Above 90°F</label>
                    <label><input type="checkbox" value="freeze-free">Freeze Free Days</label>
                    <label><input type="checkbox" value="gdd">Growing Degree Days</label>
                    <label><input type="checkbox" value="con-wet">Consecutive Wet Days</label>
                    <label><input type="checkbox" value="con-dry">Consecutive Dry Days</label>
                    <label><input type="checkbox" value="dry-days">Dry Days</label>
                    <label><input type="checkbox" value="wet-days">Wet Days</label>
                </div>
                <h3 class="section-title">Emission Scenarios</h3>
                <div class="multiselect">
                    <label><input type="checkbox" value="ssp126"> Moderating Emissions (SSP1-2.6)</label>
                    <label><input type="checkbox" value="ssp245"> Middle of the Road (SSP2-4.5)</label>
                    <label><input type="checkbox" value="ssp370"> High Emissions (SSP3-7.0)</label>
                    <label><input type="checkbox" value="ssp585"> Accelerating Emissions (SSP5-8.5)</label>
                </div>
                <div id="selected-report-div" style="background: white; padding: 10px; border-radius: 8px; border: 1px solid #ddd; margin: 10px 0;">
                    Selected Location: No Location Selected! Please Click a Polygon.
                </div>
                <div class="controls" id="report-button">
                    <button onclick="generateReport()" disabled>Generate Report</button>
                </div>
            </div>
        </div>
    </div>
    </div>
    </div>


    <script>
        const palettes = {
            'pr': 'YlGnBu',
            'pet': 'OrRd',
            'penman': 'OrRd',
            'etr': 'OrRd',
            'tmmn': 'Blues',
            'tasmin': 'Blues',
            'tas': 'RdYlBu',
            'tmmx': 'Reds',
            'tasmax': 'Reds',
            'above90': 'YlOrRd',
            'rmax': 'PuBuGn',
            'rmin': 'PuBuGn',
            'th': 'PuRd',
            'erc': 'PuRd',
            'vpd': 'OrRd',
            'vs': 'RdPu',
            'sfcWind': 'RdPu',
            'sph': 'Oranges',
            'srad': 'YlOrRd',
            'afg': 'Greens',
            'bgr': 'Greens',
            'pfg': 'Greens',
            'shr': 'Greens',
            'tre': 'Greens',
            'evi': 'Greens',
            'ndvi': 'Greens',
            'et_m16': 'OrRd',
            'pet_m16': 'OrRd',
            'gpp': 'PuRd',
            'afgnpp': 'OrRd',
            'pfgnpp': 'OrRd',
            'shrnpp': 'OrRd',
            'trenpp': 'OrRd',
            'con-dry': 'YlOrRd',
            'con-wet': 'BuPu',
            'dry-days': 'YlOrRd',
            'freeze-free': 'RdPu', 
            'gdd': 'YlOrBr',
            'wet-days': 'BuPu',
        };

        const raster_units = {
            hurs: "percent",
            pr: "mm",
            rsds: "W m-2",
            rlds: "W m-2",
            sfcWind: "m/s",
            tas: "kelvin",
            tasmax: "kelvin",
            tasmin: "kelvin",
            penman: "mm",
            erc: "",
            etr: "mm", 
            pet: "mm",
            rmax: "percent",
            rmin: "percent",
            sph: "kg/kg",
            tmmn: "K",
            tmmx: "K",
            vpd: "kPa",
            vs: "m/s",
            above90: "",
            "con-dry": "",
            "con-wet": "",
            "dry-days": "",
            "freeze-free": "",
            gdd: "",
            "wet-days": "",
            afg: "percent",
            bgr: "percent",
            pfg: "percent",
            shr: "percent",
            tre: "percent",
            evi: "",
            ndvi: "",
            et_m16: "mm",
            pet_m16: "mm",
            gpp: "kg m-2",
            afgnpp: "kg m-2",
            pfgnpp: "kg m-2",
            shrnpp: "kg m-2",
            trenpp: "kg m-2"
        };

        const units = {
            hurs: '%',
            pr: 'in',
            rsds: 'W/m²',
            rlds: 'W/m²', 
            sfcWind: 'mi/hr',
            tas: '°F',
            tasmax: '°F',
            tasmin: '°F',
            penman: 'in',
            erc: '',
            etr: 'in',
            pet: 'in',
            rmax: '%',
            rmin: '%',
            sph: 'kg/kg',
            tmmn: '°F',
            tmmx: '°F',
            vpd: 'mb',
            vs: 'mi/hr',
            above90: '',
            'con-dry': '',
            'con-wet': '',
            'dry-days': '',
            'freeze-free': '',
            gdd: '',
            'wet-days': '',
            afg: '%',
            bgr: '%',
            pfg: '%',
            shr: '%',
            tre: '%',
            evi: '',
            ndvi: '',
            et_m16: 'in',
            pet_m16: 'in',
            gpp: 'kg/m²',
            afgnpp: 'kg/m²',
            pfgnpp: 'kg/m²',
            shrnpp: 'kg/m²',
            trenpp: 'kg/m²'
        };
        function standardNormalCDF(z) {
            // constants
            const p = 0.3275911;
            const a1 = 0.254829592;
            const a2 = -0.284496736;
            const a3 = 1.421413741;
            const a4 = -1.453152027;
            const a5 = 1.061405429;

            const sign = (z >= 0) ? 1 : -1;
            z = Math.abs(z) / Math.sqrt(2.0);

            const t = 1.0 / (1.0 + p * z);
            const erf = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-z * z);
            const cdf = 0.5 * (1.0 + sign * erf);
            return cdf;
        }

        /**
         * Calculates the Mann-Kendall trend test statistic (S),
         * variance (Var(S)), Z-score, and p-value.
         * Handles ties in the data.
         *
         * @param {number[]} dataArray The input time series data.
         * @returns {{s: number, varS: number, z: number, pValue: number} | null}
         * An object with test results or null if input is invalid.
         */
        function mannKendall(dataArray) {
            const n = dataArray.length;

            // Basic validation
            if (n < 8) {
                console.warn("Mann-Kendall test is generally more reliable with at least 8-10 data points. Results for N < 8 might be less accurate.");
                // Allow calculation for N >= 3, but warn. Let's require at least 3.
                if (n < 3) {
                    console.error("Need at least 3 data points for the test.");
                    return null;
                }
            }
            if (!Array.isArray(dataArray) || dataArray.some(isNaN)) {
                console.error("Input must be a valid array of numbers.");
                return null;
            }


            let s = 0;
            for (let j = 1; j < n; j++) {
                for (let i = 0; i < j; i++) {
                    s += Math.sign(dataArray[j] - dataArray[i]);
                }
            }

            // Calculate variance, accounting for ties
            const uniqueValues = {};
            dataArray.forEach(value => {
                uniqueValues[value] = (uniqueValues[value] || 0) + 1;
            });

            const tieCorrection = Object.values(uniqueValues)
                .filter(count => count > 1)
                .reduce((sum, t) => sum + t * (t - 1) * (2 * t + 5), 0);

            const varS = (n * (n - 1) * (2 * n + 5) - tieCorrection) / 18.0;

            if (varS <= 0) {
                // If variance is zero (e.g., all values are the same), Z is undefined. No trend.
                // Or handle very small N where formula might break down.
                if (s === 0) return { s: s, varS: 0, z: 0, pValue: 1.0 };
                else {
                    console.warn("Variance of S is zero or negative. Cannot calculate Z-score reliably. This might happen with very short series or series with little variation.");
                    // Returning p=1 as the most conservative estimate (no trend)
                    return { s: s, varS: varS, z: NaN, pValue: 1.0 };
                }
            }

            // Calculate Z-score with continuity correction
            let z = 0;
            if (s > 0) {
                z = (s - 1) / Math.sqrt(varS);
            } else if (s < 0) {
                z = (s + 1) / Math.sqrt(varS);
            } // if s === 0, z remains 0

            // Calculate two-tailed p-value from Z-score using standard normal CDF
            const pValue = 2 * (1 - standardNormalCDF(Math.abs(z)));

            return pValue;
        }

        function render_historical_plot(dat, selectedVariable, parts) {
            let dat_filtered = [];
            const selectedTime = document.getElementById('historical-time-selector');
            if (selectedTime.value === 'annual') {
                const groupedData = {};
                dat.forEach(item => {
                    if (item.name === null) {
                        return;
                    }
                    const year = item.date.split('-')[0];
                    if (!groupedData[year]) {
                        groupedData[year] = { year: year, value: 0, count: 0 };
                    }
                    if (['pr', 'etr', 'pet'].includes(selectedVariable.value)) {
                        groupedData[year].value += item.value; // Sum for precipitation and ET
                    } else {
                        groupedData[year].value += item.value; // Running sum for mean
                        groupedData[year].count++; // Count for mean calculation
                    }
    
                });
                // Calculate means for non-summed variables
                if (!['pr', 'etr', 'pet'].includes(selectedVariable.value)) {
                    Object.values(groupedData).forEach(item => {
                        item.value = item.value / item.count;
                    });
                }
                dat_filtered = Object.values(groupedData).map(item => ({ date: `${item.year}-01-01`, value: item.value })); // Use Jan 1 as a placeholder date
            } else {
                // Filter data for the selected month
                dat_filtered = dat.filter(item => {
                    const month = item.date.split('-')[1];
                    const sel_month = String(new Date(Date.parse(`1970-${selectedTime.value}-01`)).getMonth() + 1).padStart(2, '0');
                    return month === sel_month;
                });
            }

            let plot_meta = {
                "loc_name": parts[parts.length - 1],
                "time": selectedTime.options[selectedTime.selectedIndex].text,
                "variable": selectedVariable.options[selectedVariable.selectedIndex].text
            }
            createChart(dat_filtered, plot_meta);
        }
        async function processPlotData(parts) {
            const activeTab = document.querySelector('.tab.active').textContent;
            const subdir = activeTab === "Historical Trends" ? "historical" : "future";
            const selectedVariable = document.getElementById('historical-variable-selector');
            const url = `https://data.climate.umt.edu/mt-normals/csvs/${subdir}/${selectedVariable.value}_${parts[0]}_${parts[1]}.csv`;
            const dat = await get_df(url);
            if (subdir === "historical") {
                render_historical_plot(dat, selectedVariable, parts);
            } else {
                render_future_plot(dat);
            }
        }
        function switchTab(index) {
            // Update tab styles
            document.querySelectorAll('.tab').forEach((tab, i) => {
                tab.classList.toggle('active', i === index);
            });

            // Update sidebar visibility
            document.querySelectorAll('.sidebar').forEach((sidebar, i) => {
                sidebar.classList.toggle('active', i === index);
            });

        }

        // Add event listener for variable selector changes
        document.getElementById('historical-variable-selector').addEventListener('change', function (e) {
            const timeSelector = document.getElementById('historical-time-selector');
            const selectedVariable = e.target.value;

            // Hide monthly options for satellite variables
            const satelliteVars = ['afg', 'bgr', 'pfg', 'shr', 'tre', 'evi', 'ndvi', 'et_m16', 'pet_m16', 'gpp', 'afgnpp', 'pfgnpp', 'shrnpp', 'trenpp'];

            Array.from(timeSelector.options).forEach(option => {
                if (option.value !== 'annual') {
                    option.style.display = satelliteVars.includes(selectedVariable) ? 'none' : '';
                }
            });

            // Reset to annual if satellite variable selected and monthly was previously selected
            if (satelliteVars.includes(selectedVariable) && timeSelector.value !== 'annual') {
                timeSelector.value = 'annual';
            }


        });

        // Function to update the map based on current selections
        async function updateMap(historical = true) {
            if (historical) {
                const selectedVariable = document.getElementById('historical-variable-selector');
                const selectedTime = document.getElementById('historical-time-selector').value;
                const url = `https://data.climate.umt.edu/mt-normals/cog/${selectedVariable.value}/${selectedTime}_mean.tif`;
                await addCOG(url, selectedVariable, true, selectedTime);
                if (most_recent_click) {
                    await processPlotData(most_recent_click);
                }
            } else {
                const selectedVariable = document.getElementById('future-variable-selector');
                const selectedTime = document.querySelector('input[name="time-period"]:checked').value;
                const selectedMapType = document.querySelector('input[name="map-type"]:checked').value;
                const url = `https://data.climate.umt.edu/mt-normals/cog/${selectedVariable.value}/${selectedTime}_${selectedMapType}.tif`;
                await addCOG(url, selectedVariable, false, selectedTime);
            }

        }

        function draw_default_message(ctx) {
            const canvas = ctx.canvas;
            const dpr = window.devicePixelRatio;
            const rect = canvas.getBoundingClientRect();
            
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            
            ctx.scale(dpr, dpr);
            canvas.style.width = rect.width + 'px';
            canvas.style.height = rect.height + 'px';

            ctx.font = "20px Arial";
            ctx.textAlign = "center"; 
            ctx.textBaseline = "middle";
            
            ctx.fillText(
                "To view a plot,",
                rect.width / 2,
                rect.height / 2 - 12
            );
            ctx.fillText(
                "please click a polygon on the map.",
                rect.width / 2,
                rect.height / 2 + 12
            );
        }
        // Initial load event
        document.addEventListener('DOMContentLoaded', updateMap);
        document.addEventListener('DOMContentLoaded', function () {
            let hist_plot_canvas = document.getElementById("historical-plot").getContext("2d");
            let future_plot_canvas = document.getElementById("future-plot").getContext("2d");   
            draw_default_message(hist_plot_canvas);
            draw_default_message(future_plot_canvas);
        });

        // Change event listeners for both selectors
        document.getElementById('historical-variable-selector').addEventListener('change', () => updateMap(true));
        document.getElementById('historical-time-selector').addEventListener('change', () => updateMap(true));

        const customWatermarkPlugin = {
            id: 'customWatermark',
            beforeDraw: (chart, args, pluginOptions) => {
                const imageSrc = "https://data.climate.umt.edu/website/assets/MCO_logo.png"; // Ensure path is correct

                if (!chart.watermarkImage) {
                    chart.watermarkImage = new Image();
                    chart.watermarkImage.src = imageSrc;
                    chart.watermarkImage.onload = () => {
                        chart.draw();
                    };
                    chart.watermarkImage.onerror = () => {
                        console.error("Watermark image failed to load:", imageSrc);
                        chart.watermarkImage = null;
                    }
                }

                if (chart.watermarkImage && chart.watermarkImage.complete && chart.watermarkImage.naturalWidth !== 0) {
                    const img = chart.watermarkImage;
                    const ctx = chart.ctx;
                    const canvas = ctx.canvas;

                    // --- 1. Define desired scale factor ---
                    const scaleFactor = 0.04; // Make it 20% of its original size. Adjust this!

                    // --- 2. Calculate the new width and height ---
                    const newWidth = img.width * scaleFactor;
                    const newHeight = img.height * scaleFactor;

                    ctx.save();

                    // --- 3. Recalculate position based on the NEW scaled dimensions ---


                    // Calculate position as a percentage of canvas size
                    const x = canvas.width * 0.95 - newWidth;  // 80% from left
                    const y = canvas.height * 0.9 - newHeight;  // 80% from top

                    // Apply transparency
                    ctx.globalAlpha = 0.3; // Adjust as needed

                    // --- 4. Draw the image using the calculated position ---
                    ctx.drawImage(img, x, y, newWidth, newHeight);

                    ctx.restore();
                }
                return true;
            }
        };



        async function get_df(f) {
            try {
                const response = await fetch(f);
                const csv = await response.text();
                const results = Papa.parse(csv, {
                    header: true,
                    dynamicTyping: true
                });
                parsed_data = results.data;
            } catch (error) {
                parsed_data = null
                console.error('Error loading CSV:', error);
            }
            const validData = parsed_data.filter(row => row && row.date && row.value);

            return validData
        }

        let historical_chart_instance;

        function resetZoom() {
            historical_chart_instance.resetZoom();
        }

        function createChart(data, plot_meta) {
            const years = data.map(row => parseInt(row.date.split('-')[0]));
            const values = data.map(row => row.value);
            const pValue = mannKendall(values);
            let datasets = [{
                label: 'Values',
                data: values,
                borderColor: 'rgb(75, 192, 192)',
                backgroundColor: 'rgba(75, 192, 192, 0.5)',
                pointRadius: 4,
                tension: 0.1,
            }];
            let extra_text;
            if (pValue < 0.05) {
                extra_text = "Trend is Statistically Significant";
                datasets[0].trendlineLinear = {
                    colorMin: "gray",
                    colorMax: "gray",
                    lineStyle: "solid",
                    width: 2,
                    projection: true
                };
            }



            const ctx = document.getElementById('historical-plot');
            if (historical_chart_instance) {
                historical_chart_instance.destroy();
            }

            historical_chart_instance = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: years,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    // Add watermark/logo configuration

                    plugins: {
                        legend: {
                            position: null,
                        },
                        title: {
                            display: true,
                            text: `Trend in ${plot_meta.loc_name} ${plot_meta.time} ${plot_meta.variable}`,
                        },
                        zoom: {
                            pan: {
                                enabled: true,
                                mode: 'xy'
                            },
                            zoom: {
                                wheel: {
                                    enabled: true,
                                },
                                pinch: {
                                    enabled: true
                                },
                                mode: 'xy',
                            }
                        },
                        subtitle: {
                            display: extra_text !== undefined,
                            text: extra_text,
                            font: {
                                weight: 'bold'
                            }
                        }
                    },
                    scales: {
                        x: {
                            ticks: {
                                callback: function (val, index) {
                                    const year = this.getLabelForValue(val);
                                    return year % 5 === 0 ? year : '';
                                }
                            }
                        },
                        y: {
                            beginAtZero: false
                        }
                    }
                },
                plugins: [customWatermarkPlugin] // --- This array REGISTERS plugin objects for *this chart only* ---
            });
        }
    </script>

    </script>

    <script>
        // Montana coordinates
        const MONTANA_CENTER = [47, -106];
        const ZOOM_LEVEL = 6.5;

        // Initialize single map instance with bounds restrictions
        const map = L.map('map', {
            zoomDelta: 0.1,
            zoomSnap: 0.1,
            minZoom: 6.5,
            maxBounds: [
            [43.5, -117.5],
            [49.5, -93.5]
            ],
            maxBoundsViscosity: 1.0
        }).setView(MONTANA_CENTER, ZOOM_LEVEL);

        // Add base tile layer
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© OpenStreetMap contributors'
        }).addTo(map);
        // Store layers for the control panel
        var overlayMaps = {};

        // Create the layer control immediately with baseLayers (first argument) instead of overlays
        const baseMaps = L.control.layers({}, null, {
            collapsed: false,
            position: 'topleft'
        }).addTo(map);

        const legend = L.control({ position: 'bottomleft' });
        legend.onAdd = function (map) {
            var div = L.DomUtil.create('div', 'legend')

            return div
        }

        legend.addTo(map);


        let current_layer = null;
        let most_recent_click;

        function updateLegend(selectedVariable) {
            const old_div = legend.getContainer().querySelector('div');
            const new_div = L.DomUtil.create('div');
            const options = current_layer.options;
            const lower_lim = options.min < 1 ? Math.round((options.min + Number.EPSILON) * 100) / 100 : Math.round(options.min);
            const upper_lim = options.max < 1 ? Math.round((options.max + Number.EPSILON) * 100) / 100 : Math.round(options.max);

            const labels = [];
            const scale = chroma.scale(options.pal).mode('lab');

            new_div.innerHTML = `
                <div class="legend-title">${selectedVariable.options[selectedVariable.selectedIndex].text} [${units[options.variable]}]</div>
                <ul>${Array.from({length: 200}, (_, i) => {
                    const normalized = i / 199;
                    const color = scale(normalized).css();
                    return `<li style="background: ${color}"></li>`;
                }).join('')}</ul>
                <div class="min">${lower_lim}</div>
                <div class="max">${upper_lim}</div>
            `;

            if (old_div == null) {
                legend.getContainer().appendChild(new_div);
            } else {
                // replace el with newEL
                legend.getContainer().replaceChild(new_div, old_div);
            }            
        }

        async function addCOG(url, selectedVariable, display = false, time_) {
            try {
                const response = await fetch(url);
                const arrayBuffer = await response.arrayBuffer();
                const georaster = await parseGeoraster(arrayBuffer);

                const min = georaster.mins[0];
                const max = georaster.maxs[0];
                var layer = new GeoRasterLayer({
                    georaster: georaster,
                    opacity: 0.7,
                    updateWhenZooming: false,
                    pixelValuesToColorFn: function (pixelValues) {
                        const pixelValue = pixelValues[0];
                        if (isNaN(pixelValue)) {
                            return 'rgba(0,0,0,0)';
                        }
                        // Get the color scale based on the variable name
                        const scale = chroma.scale(palettes[selectedVariable.value]).mode('lab');
                        // Normalize the value between 0 and 1
                        const normalized = (pixelValue - min) / (max - min);
                        // Get color and convert to rgba
                        const color = scale(normalized).alpha(1);
                        return color.css('rgba');
                    },
                    min: min,
                    max: max,
                    pal: palettes[selectedVariable.value],
                    variable: selectedVariable.value,
                });

                layer.name = selectedVariable.value;
                layer.time = time_;

                // baseMaps.addBaseLayer(layer, name_);
                if (current_layer !== null) {
                    map.removeLayer(current_layer);
                }
                current_layer = layer;

                if (display) {
                    current_layer.addTo(map);
                }
                updateLegend(selectedVariable);


            } catch (error) {
                console.error('Error loading COG:', error);
            }
        }

        async function loadFlatGeobufLayer(url, layerId, layerName, add_to_group = true, style = {
            fillColor: "rgba(0, 0, 0, 0)",
            fillOpacity: 0.9,
            color: "black",
            weight: 1
        }) {
            try {
                // Create a feature group for the layer
                const layerGroup = L.featureGroup();
                const response = await fetch(url);

                for await (const feature of flatgeobuf.deserialize(response.body)) {
                    var feat = L.geoJSON(feature, {
                        style: () => style,
                        onEachFeature: (feature, layer) => {
                            if (feature.properties && add_to_group) {
                                layer.bindTooltip(
                                    feature.properties.name
                                );
                            }
                        }
                    })

                    if (add_to_group) {
                        feat.addTo(layerGroup);
                    } else {
                        feat.addTo(map);
                    }
                }

                if (add_to_group) {
                    // Add the layer to the overlay maps object
                    overlayMaps[layerId] = layerGroup;
                    baseMaps.addBaseLayer(layerGroup, layerName);
                }

                if (Object.keys(overlayMaps).length === 1) {
                    layerGroup.addTo(map);
                }
            } catch (error) {
                console.error(`Error loading FlatGeobuf layer ${layerId}:`, error);
            }
        }
        async function main() {

            await loadFlatGeobufLayer(
                "https://data.climate.umt.edu/mt-normals/fgb/mt.fgb",
                "",
                "",
                false,
                style = {
                    fillColor: "rgba(0, 0, 0, 0)",
                    fillOpacity: 0.9,
                    color: "black",
                    weight: 3
                }
            );

            await loadFlatGeobufLayer(
                "https://data.climate.umt.edu/mt-normals/fgb/explorer/counties.fgb",
                "counties",
                "Counties"
            );

            await loadFlatGeobufLayer(
                "https://data.climate.umt.edu/mt-normals/fgb/explorer/blm.fgb",
                "blm",
                "BLM Districts"
            );

            await loadFlatGeobufLayer(
                "https://data.climate.umt.edu/mt-normals/fgb/explorer/hucs.fgb",
                "hucs",
                "HUCs"
            );

            await loadFlatGeobufLayer(
                "https://data.climate.umt.edu/mt-normals/fgb/explorer/tribes.fgb",
                "tribes",
                "Tribal Lands"
            );

            f = 'https://data.climate.umt.edu/mt-normals/csvs/historical/rmax_huc_17010105.csv'

            Object.entries(overlayMaps).forEach(([key, value]) => {
                value.on("click", async (event) => {
                    const parts = event.layer.feature.properties.id.split("_");
                    most_recent_click = parts;
                    document.getElementById('selected-report-div').innerHTML = `Selected Location: ${parts[parts.length - 1]}`;
                    document.getElementById('report-button').querySelector('button').disabled = false;
                    await processPlotData(parts);
                });
            });

        }
        main();
    </script>
</body>

</html>